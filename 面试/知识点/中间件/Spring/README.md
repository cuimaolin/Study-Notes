Spring框架的IoC容器？（华为Cloudbu一面，淘宝一面）

> - IOC容器具有依赖注入的功能，它可以创建对象，IOC负责实例化、定位、配置应用程序中对象及建立这些对象之间的依赖。
> - 通常new一个实例，控制权由程序员控制，而“控制反转”是指new实例的工作不由程序员来做而是交给spring容器来做

Spring注入有哪些方式？怎么将依赖建立起来？（华为Cloudbu一面，淘宝一面）

> - 基于构造函数的依赖注入。当容器调用带有一组参数的类构造函数时，基于构造函数的DI就完成了，其中每个参数代表一个对其他类的依赖。
> - 基于设置函数setter的依赖注入。当容器调用一个无参的构造函数或一个无参的静态factory方法来初始化bean后，通过容器在bean上调用setter函数，基于setter函数的依赖注入就完成了。
> - 基于注解的依赖注入。使用相关类，方法或者字段声明的注解，将bean配置移动到组件类本身。

Spring中AOP的实现？面向接口、面向类是怎么实现的？（华为Cloudbu一面，淘宝一面，阿里3一面，Lazada二面）

> AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。
>
> - 委托类
    >   - 需要在实现类上加上`@Aspect`的注解，还需要通过`@Pointcut`注解来申明"切点"，即委托类和委托方法的路径
>   - 有了这些信息就足够获取委托类了。这里充分用到Java反射，先找到包含`@Aspect`注解的类，然后找到该类下的`@Pointcut`注解，读取所定义的委托类和委托方法注解，就完全能拿到委托类对象
> - 代理类
    >   - 因为我们使用的是动态代理，这里的代理类可以被替换成`代理方法`。同样，我们在`@Aspect`注解的类中，用`@Around` `@Before` `@After`修饰的方法，就是我们想要的代理方法。
> - 总结
    >   - 我们可以通过`BeanFactoryPostProcessor`的实现类，完成对所有`BeanDefinition`的扫描，找出我们定义的所有的切面类，然后循环里面的方法，找到切点、以及所有的通知方法，然后根据注解判断通知类型（也就是前置，后置还是环绕），最后解析切点的内容，扫描出所有的目标类。这样就获取了`委托类` 和 `代理方法`。
>   - 现在`委托类` 和 `代理方法` 都有了，我们知道在动态代理模式中，最终的目的是将委托类的方法执行，替换成代理类的方法执行。但是在Spring中，我们是感知不到`代理类`的，我们在代码中还是调用原`委托类`的方法，那么Spring框架是如何神不知鬼不觉地将`委托类`替换成`代理类`的呢？
>   - 在Bean的生命周期中，Bean在初始化前后会执行`BeanPostProcessor`的方法。可以把它理解成一个增强方法，可以将原始的Bean经过“增强”处理后加载到Ioc容器中。这就是一个天然的代理方法，原始的Bean就是`委托类`，在此处实现代理方法生成代理类，再将代理类加载进Ioc容器。

servlet的类继承层次（腾讯云二面）