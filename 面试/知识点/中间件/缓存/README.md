Redis数据缓存和分布式锁做的是什么？（快手一面，淘宝一面，腾讯云二面）

> 手机验证码功能。根据手机号生成随机的验证码并设置过期时间，存储在Redis中。使用到了String数据结构。
>
> Redis分布式锁主要利用Redis的setnx命令。
>
> - 加锁命令：`SETNX key value`，当键不存在时，对键进行设置操作并返回成功，否则返回失败。
    >   - `key`是锁的唯一标识，一般按业务来决定命名，`value`可以使用`uuid`来保证唯一；
> - 解锁命令：`DEL key`，通过删除键值对释放锁，以便其他线程可以通过SETNX命令来获取锁；
> - 锁超时：`EXPIRE key timeout`，设置key的超时时间，以保证即使锁没有被显式释放，锁也可以在第一时间后自动释放，避免资源用于被锁住。

为什么会想到用到分布式锁？（快手一面，深信服一面，腾讯云二面）

> 如果在一个分布式系统中，我们从数据库中读取一个数据，然后修改保存，这种情况很容易遇到并发问题。因此读取和更新保存不是一个原子操作，在并发时就会导致数据的不正确性。比如电商秒杀活动，库存数量的更新就是遇到。如果单机应用，直接使用本地锁就可以避免。如果是分布式应用，本地锁派不上用场，这时就需要引入分布式锁来解决。
>
> 分布式锁的目的是为了保证多台服务器在执行某一段代码时保证只有一台服务器执行。

是一个商品一个锁吗？如何防止一个用户锁定了多个商品？（深信服一面）

> 是一个商品一个锁，因为Redis是单线程的且基于IO复用模型的，因此不会出现一个用户锁定多个商品的情况

锁是否真的实现商品被超购（腾讯云二面）

SETNX是原子操作吗？不是原子操作会出现什么问题（腾讯云二面）

> SETNX和EXPIRE是非原子性的
>
> 如果SETNX成功，在设置锁超时时间后，服务器挂掉、重启或网络问题等，导致EXPIRE命令没有被执行，锁没有设置超时时间变成死锁
>
> 解决方法：
>
> ```lua
> if (redis.call('setnx', KEYS[1], ARGV[1]) < 1)
> then return 0;
> end;
> redis.call('expire', KEYS[1], tonumber(ARGV[2]));
> return 1;
> 
> // 使用实例
> EVAL "if (redis.call('setnx',KEYS[1],ARGV[1]) < 1) then return 0; end; redis.call('expire',KEYS[1],tonumber(ARGV[2])); return 1;" 1 key value 100
> ```


Redis为什么那么快？（淘宝一面，腾讯云二面，腾讯CDG事务开发一面）

> [一文搞懂 Redis 高性能之 IO 多路复用](https://xie.infoq.cn/article/b3816e9fe3ac77684b4f29348)
>
> 1. Redis完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速
> 2. 数据结构简单，对数据的操作也简单；
> 3. 采用单线程，避免了不必要的上下文切换和竞争条件；
> 4. 使用多路复用IO模型，不在IO上浪费时间

Redis和Memcache的区别（今日头条测开二面）

> 一、共同点
>
> 1. 都是基于内存的数据库，一般都用来当做缓存使用。
> 2. 都有过期策略。
> 3. 两者的性能都非常高。
>
> 二、区别
>
> 1. Redis 支持更丰富的数据类型（支持更复杂的应用场景）。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。
> 2. Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中。
> 3. Redis 有灾难恢复机制。因为可以把缓存中的数据持久化到磁盘上。
> 4. Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。
> 5. Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。
> 6. Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。（Redis 6.0 引入了多线程 IO ）
> 7. Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。
> 8. Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。

Redis用到哪些命令（腾讯TEG一面）

Redis有哪些数据结构？（淘宝一面，今日头条测开二面）

> - STRING 字符串
> - LIST 列表
> - SET 无序集合
> - HASH 包含键值对的无序散列表
> - ZSET 有序集合

有序集合有了解嘛？跳表数据结构有了解嘛？（淘宝一面）

> 跳跃表是有序集合的底层实现之一。
>
> 跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。
>
> 在查找时，从上层指针开始查找，找到对应区间之后再到下一层去查找。
>
> 与红黑树灯平衡树相比，跳跃表具有以下优点：
>
> - 插入速度非常快速，因为不需要进行旋转等操作来维护平衡性
> - 更容易实现
> - 支持无锁操作
>
> 跳跃表每个节点的结构
>
> ```c
> struct zslnode{
>     string value;
>     double score;
>     zslnode*[] forwards;    // 多层连接指针
>     zslnode*[] backward;    //回溯指针
> }
> ```

从zset删除数据的时间复杂度（腾讯云二面）

> [有序集(Sorted Set)](https://redis.readthedocs.io/en/2.4/sorted_set.html)
>
> - 查找任意数据的时间复杂度O(logN)
>
> - 插入数据的时间复杂度O(logN)
>
> - 跳表的删除O(logN)

Redis中AOF和RDB有什么区别？哪种方法更优？（淘宝一面，腾讯CDG事务开发一面）

> - RDB是一次全量备份，AOF日志是连续的增量备份；
> - 存储。RDB是内存数据的二进制序列化形式，而AOF日志记录的是修改内存数据的指令；
> - 数据丢失。RDB往往会造成一定时间的数据丢失
> - 恢复速度。RDB快照恢复速度非常快，而AOF由于需要处理巨大的写入会影响Redis性能

Redis的分布式（Lazada一面）

> 一、CAP理论
>
> - **C** - **C**onsistent ，一致性
> - **A** - **A**vailability ，可用性
> - **P** - **P**artition tolerance ，分区容忍性
>
> 分布式系统的节点往往都是分布在不同的机器上进行网络隔离开的，这意味着必然会有网络断开的风险，这个网络断开的场景的专业词汇叫着「**网络分区**」。
>
> 在网络分区发生时，两个分布式节点之间无法进行通信，我们对一个节点进行的修改操作将无法同步到另外一个节点，所以数据的「一致性」将无法满足，因为两个分布式节点的数据不再保持一致。除非我们牺牲「可用性」，也就是暂停分布式节点服务，在网络分区发生时，不再提供修改数据的功能，直到网络状况完全恢复正常再继续对外提供服务。
>
> 2、最终一致
>
> Redis 的主从数据是异步同步的，所以分布式的 Redis 系统并不满足「**一致性**」要求。
>
> 当客户端在 Redis 的主节点修改了数据后，立即返回，即使在主从网络断开的情况下，主节点依旧可以正常对外提供修改服务，所以 Redis 满足「**可用性**」。
>
> Redis 保证「**最终一致性**」，从节点会努力追赶主节点，最终从节点的状态会和主节点的状态将保持一致。如果网络断开了，主从节点的数据将会出现大量不一致，一旦网络恢复，从节点会采用多种策略努力追赶上落后的数据，继续尽力保持和主节点一致。
>
> 3、主从同步
>
> 类似于RDB快照和AOF

Redis如果整个集群都掉电挂了，且没有持久化，怎么办（腾讯TEG一面）
