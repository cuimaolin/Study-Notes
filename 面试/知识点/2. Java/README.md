### 2.1 基础

==和equals有什么区别（华为Cloudbu一面，腾讯CDG一面）

> - ==对于基本类型来说是值比较，对于引用类型来说是比较的引用；
> - String、Integer重写了equals方法，一般情况下equals比较的是值是否相等。

StringBuilder和StringBuffer（华为Cloudbu一面）

> 可变性：
> 
> - String不可变
> - StringBuffer和StringBuilder可变
> 
> 线程安全：
> 
> - String不可变，因此是线程安全的
> - StringBuilder不是线程安全的
> - StringBuffer是线程安全的，内部使用synchronized进行同步

接口和抽象类的区别（华为Cloudbu一面，淘宝一面，腾讯TEG一面）

> - 实现。抽象类的子类使用extends来继承（定义抽象类就是让其他类继承的），接口必须使用implements来实现接口；
> 
> - 构造函数。抽象类可以有构造函数；接口不能有
> 
> - main方法。抽象类可以有main方法，并且我们能运行它；接口不能有main方法。
> 
> - 实现数量。类可以实现很多个接口；但是只能继承一个抽象类
> 
> - 访问修饰符。接口中的方法默认使用public修饰；抽象类中的方法可以是任意访问修饰符。

继承和重载（华为Cloudbu一面）

> 继承：子类可以使用父类中的一些成员变量和方法，使用extends关键字实现
> 
> 重载：是指一个类中定义了多个重名方法，它们的参数列表是不相同的。

Java异常的类型（华为Cloudbu一面）

> ![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/PPjwP.png)

解释一下Java的序列化和反序列化？什么时候会用到？序列化的底层实现（腾讯CDG一面，深信服一面）

> - 序列化就是将一个对象转换为字节序列，方便存储和传输
>   - 序列化：ObjectOuputStream.writeObject()
>   - 反序列化：ObjectInputStream.readObject()
> - 不会对静态变量进行初始化，因为序列化只是保存对象的状态，静态变量属于类的状态
> - 序列化的类需要实现Serializable接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常
> - transient关键字可以使一些熟悉不会被序列化

Java的泛型（深信服一面）

> 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。

Java和Python的区别，各自有什么缺点？（深信服二面，今日头条测开二面）

> - Java必须显式声明变量名，而动态类型的Python不需要声明变量
> - Python虚拟机没有Java强，Java虚拟机是Java的核心，Python的核心是可以很方便地使用c语言函数或c++库
> - Java是一种静态类型语言，Python是一种动态类型语言
> - Java 的类型要声明，Python 的类型不需要
> - Python是全动态性的，可以在运行时自己修改自己的代码，Java只能通过变通方法实现

python是怎么执行的，需要编译链接吗？（今日头条测开二面）

> [python程序需要编译吗](https://cloud.tencent.com/developer/article/1725774)
> 
> 因为 Python 代码在运行前，会先编译（翻译）成中间代码，每个 .py 文件将被换转成 .pyc 文件，.pyc 就是一种字节码文件，它是与平台无关的中间代码，不管你放在 Windows 还是 Linux 平台都可以执行，运行时将由虚拟机逐行把字节码翻译成目标代码。
> 
> [Java到底是编译型语言还是解释型语言？](https://blog.fundebug.com/2019/01/25/is-java-a-compiled-or-an-interpreted-programming-language/)
> 
> java是解释型的语言，因为虽然java也需要编译，编译成.class文件，但是并不是机器可以识别的语言，而是字节码，最终还是需要 jvm的解释，才能在各个平台执行，这同时也是java跨平台的原因。所以可是说java即是编译型的，也是解释型，但是假如非要归类的话，从概念上的定义，恐怕java应该归到解释型的语言中

面向对象和面向过程的区别（阿里3一面）

> - 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了
> - 面向对象事把构成问题事物分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在解决问题的步骤中的行为

面向对象中的设计原则？使用了什么设计模式？（阿里3一面）

> - 单一责任原则。
>   - 修改一个类的原因只有一个
>   - 换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。
>   - 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱这个类完成其他职责的能力
> - 开放封闭原则
>   - 类应该对扩展开放，对修改关闭
>   - 扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码
>   - 符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码
> - 里氏替换原则
>   - 子类必须能够替换掉所有父类对象
>   - 继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。
>   - 如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。
> - 接口分离原则
>   - 不应该强迫客户依赖于它们不用的方法。
>   - 因此使用多个专门的接口比使用单一的总接口要好。
> - 依赖倒置原则
>   - 高层模块不应该依赖于低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。
>   - 高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。
>   - 依赖意味着
>     - 任何变量都不应该持有一个指向具体类的指针或者引用；
>     - 任何类都不应该从具体类派生；
>     - 任何方法都不应该覆写它的任何基类中的已经实现的方法。

设计模式有什么用？（阿里3一面）

> 为了代码可重用性、增加可维护性，让代码更容易被他人理解、保证代码可靠性。设计模式使代码真正工程化。

Java动态代理的场景（腾讯CDG一面）

> - 静态代理
>   - 概念
>     - 静态代理其实就是设计模式中的代理模式；
>     - 代理模式为其它对象提供一种代理以控制对这个对象的访问
>   - 缺点
>     - 大量使用这种静态代理，会使我们系统内的类的规模增大，并不易于维护；
>     - 并且由于Proxy和RealSubject的功能本质上是相同的，Proxy只是起到了中介的作用，这种代理在系统中的存在，导致系统结构比较臃肿和松散
> - 动态代理
>   - 概念
>     - 在运行状态中，需要代理的地方，根据Subject和RealSubject，动态地创建一个Proxy，用完之后，就会销毁，这样就可以避免Proxy角色的class在系统中冗余的问题了。
>     - Java动态代理基于经典代理模式，引入了一个InvocationHandler，InvocationHandler负责统一管理所有的方法调用。
>     - 基于Java内部的反射机制完成的
>   - 步骤
>     - 获取RealSubject上的所有接口列表
>     - 确定要生成的代理类的类名，默认为：com.sun.proxy.$ProxyXXXX
>     - 根据需要实现的接口信息，在代码中动态创建该Proxy类的字节码
>     - 将对应的字节码转换为对应的class对象
>     - 创建InvocationHandler实例handler，用来处理Proxy所有方法调用
>     - Proxy的class对象以创建的handler对象为参数，实例化一个proxy对象

Java的反射机制？（深信服一面）

> [深入理解Java反射](https://zhuanlan.zhihu.com/p/60805342)
> 
> 通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。
> 
> - **优点** ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利
> - **缺点** ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。

### 2.2 虚拟机

JVM的内存模型（百度一面）

> ![img](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.png)
>
> 一、程序计数器
>
> 程序计数器是线程私有的，它的生命周期与线程相同，主要有两个作用：
>
> 1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
> 2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
>
> 二、Java虚拟机栈
>
> - Java 虚拟机栈也是线程私有的，它的生命周期和线程相同
> - 描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。
> - Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。
>
> 三、本地方法栈
>
> - 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。
>
> 四、堆
>
> - Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。
> - 此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。
>
> 五、方法区
>
> - 方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

垃圾回收算法（腾讯CDG一面，腾讯TEG一面，深信服一面，百度一面）

> 一、判断对象是否可以被回收
>
> 1、引用计数算法。
>
> - 为对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1。
> - 引用计数为0的对象可被回收。但是当出现循环引用时，此时计数器永远不为0，导致无法对它们进行回收。
>
> 2、可达性分析算法
>
> - 以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收
> - Java 虚拟机使用该算法来判断对象是否可被回收
>
> 二、垃圾回收算法
>
> 1、标记-清除算法
>
> 该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。这种垃圾收集算法会带来两个明显的问题：
>
> - **效率问题**
>
> - **空间问题（标记清除后会产生大量不连续的碎片）**
>
> 2、标记-复制算法
>
> 为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。
>
> 3、标记-整理算法
>
> 根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。
>
> 4、分代收集算法
>
> **比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。**
>
> 三、垃圾收集器
>
> 1、[Serial 收集器](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_41-serial-%E6%94%B6%E9%9B%86%E5%99%A8)
>
> Serial（串行）收集器不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **"Stop The World"** ），直到它收集结束。
>
> 它**简单而高效（与其他收集器的单线程相比）**。
>
> **新生代采用标记-复制算法，老年代采用标记-整理算法。**
>
> ![Serial 收集器](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/46873026.png)
>
> 2、[ParNew 收集器](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_42-parnew-%E6%94%B6%E9%9B%86%E5%99%A8)
>
> **ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。**
>
> **新生代采用标记-复制算法，老年代采用标记-整理算法。**
>
> ![ParNew 收集器](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/22018368.png)
>
> 3、[Parallel Scavenge 收集器](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_43-parallel-scavenge-%E6%94%B6%E9%9B%86%E5%99%A8)
>
> **Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。**
>
> **新生代采用标记-复制算法，老年代采用标记-整理算法。**
>
> ![Parallel Scavenge 收集器](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/parllel-scavenge%E6%94%B6%E9%9B%86%E5%99%A8.png)
>
> 4、[Serial Old 收集器](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_44serial-old-%E6%94%B6%E9%9B%86%E5%99%A8)
>
> **Serial 收集器的老年代版本**，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。
>
> 5、[Parallel Old 收集器](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_45-parallel-old-%E6%94%B6%E9%9B%86%E5%99%A8)
>
> **Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。
>
> 6、[CMS 收集器](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_46-cms-%E6%94%B6%E9%9B%86%E5%99%A8)
>
> **CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。**
>
> **CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：
>
> - **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
> - **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
> - **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
> - **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。
>
> ![CMS 垃圾收集器](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png)
>
> 主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：
>
> - **对 CPU 资源敏感；**
> - **无法处理浮动垃圾；**
> - **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**
>
> 7、[G1 收集器](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_47-g1-%E6%94%B6%E9%9B%86%E5%99%A8)
>
> - **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
> - **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
> - **空间整合**：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。
> - **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。
>
> **G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)** 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

JVM的引用回收的计数器保存在哪里？（深信服一面）

> [对象引用计数保存在哪里？](https://blog.csdn.net/WangErice/article/details/105095579)

stop the world在哪些阶段发生（腾讯TEG一面）

> 垃圾回收时，必须暂停其他所有工作线程

在JVM和类加载的过程如何实现多态（腾讯云一面）

new一个对象的过程，从创建到垃圾回收，双亲委派机制（今日头条一面，腾讯CDG一面，腾讯云二面，华为公共开发一面）

> [java new一个对象的过程中发生了什么](https://www.cnblogs.com/JackPn/p/9386182.html)
>
> ![img](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E5%AE%8C%E5%96%84.png)
>
> 一、类加载过程
>
> 1、加载
>
> 由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例
>
> 2、验证
>
> 确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求
>
> 3、准备
>
> 为类中的所有静态变量分配内存空间，并为其设置一个初始值（由于还没有产生对象，实例变量不在此操作范围内）
>
> 4、解析
>
> 将常量池的符号引用替换为直接引用的过程。
>
> 其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。
>
> 5、初始化
>
> - 为静态变量赋值
>
> - 执行static代码块
>
> 因为子类存在对父类的依赖，所以**类的加载顺序是先加载父类后加载子类，初始化也一样。**不过，父类初始化时，子类静态变量的值也有有的，是默认值。
>
> 最终，方法区会存储当前类类信息，包括类的**静态变量**、**类初始化代码**（**定义静态变量时的赋值语句** 和 **静态初始化代码块**）、**实例变量定义**、**实例初始化代码**（**定义实例变量时的赋值语句实例代码块**和**构造方法**）和**实例方法**，还有**父类的类信息引用。**
>
> 二、创建对象
>
> 1、在堆区分配对象需要的内存
>
> - 分配的内存包括本类和父类的所有实例变量，但不包括任何静态变量
>
> 2、对所有实例变量赋默认值
>
> - 将方法区内对实例变量的定义拷贝一份到堆区，然后赋默认值
>
> 3、执行实例初始化代码
>
> - 初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法
>
> 4、如果有类似于Child c = new Child()形式的c引用的话，在栈区定义Child类型引用变量c，然后将堆区对象的地址赋值给它
>
> 三、双亲委派机制
>
> ![ClassLoader](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/classloader_WPS%E5%9B%BE%E7%89%87.png)
>
> 有一个类需要类加载器去加载，如果有父类，先让父类去加载，如此往上追朔，直到根类加载器，然后根类加载器尝试去加载，加载成功则结束，加载失败，又往下，一层层的尝试去加载，最终如果没有加载成功，则报错ClassNotFound。


### 2.3 容器

Java的容器有哪些？（华为Cloudbu一面，腾讯CDG一面）

> 容器：
>
> - Collection。存储对象的集合
    >   - Set
          >     - TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如HashSet，HashSet查找的时间复杂度为O(1)，TreeSet为O(logn)。
>     - HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并失去了元素的插入顺序信息，也就是说使用Iterator遍历HashSet得到的结果是不确定的。
>     - LinkedHashSet：具有HashSet的查找效率，并且内部使用双向链表维护元素的插入顺序。
>   - List
      >     - ArrayList：基于动态数组实现，支持随机访问。
>     - Vector：和ArrayList类似，但它是线程安全的
>     - LinkedList：基于双向链表实现，只能顺序访问，但是可以快速在链表中间插入和删除元素。不仅如此，LinkedList还可以用于栈、队列和双向队列。
>   - Queue
      >     - LinkedList：可以用它来实现双向队列
>     - PriorityQueue：基于堆结构实现，可以用它来实现优先队列。
> - Map
    >   - TreeMap：基于红黑树实现
>   - HashMap：基于哈希表实现
>   - HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。
>   - LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。

Java HashMap是怎么实现的（今日头条一面，阿里3一面，百度一面）

> JDK1.8 之前 `HashMap` 由数组+链表组成的，数组是 `HashMap` 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间

如果HashMap的链表过长是否会影响查找效率（阿里3一面）

HashMap为什么是线程不安全的？（腾讯CDG一面）

> - 多线程的put可能导致元素的丢失
> - put和get并发时，可能导致get为null
> - JDK7中并发put会造成循环链表，导致get出现死循环

JDK8 HashMap是否会导入死循环？（阿里3一面）

> 主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。
>
> 详情请查看：[疫苗：Java HashMap的死循环 | 酷 壳 - CoolShell](https://coolshell.cn/articles/9606.html)

HashMap为什么大于8要转换为红黑树（今日头条一面）

> 理想情况下，在随机哈希码下，哈希表中节点 的频率遵循泊松分布，而且根据统计，忽略方差，列表长度为K的期望出现的次数是以上的结果，可以看到其实在8的时候概率就已经很小了，再往后调整并没有很大意义。

concurrentHashMap如何扩容？（腾讯CDG一面）

> - 当前键值对的数量大于loadFactor✖capacity时即进行扩容
> - 当需要扩容时，令capacity为原来的两倍
> - 扩容操作使用resize()实现，需要把oldTable的所有键值对重新插入newTable中

HashMap和ConcureentHashMap的区别？HashMap如何实现线程安全？ConcurentHashMap锁的实现，是在哪一个版本实现的，哪一个版本进行改进（腾讯CDG一面，腾讯云二面，百度一面）

> JDK1.7
>
> 首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。
>
> **`ConcurrentHashMap` 是由 `Segment` 数组结构和 `HashEntry` 数组结构组成**。
>
> Segment 实现了 `ReentrantLock`,所以 `Segment` 是一种可重入锁，扮演锁的角色。`HashEntry` 用于存储键值对数据。
>
> JDK1.8
>
> `ConcurrentHashMap` 取消了 `Segment` 分段锁，采用 CAS 和 `synchronized` 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）
>
> `synchronized` 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。

向两个HashMap分别put1000条和10000条数据，并且其初始容量为1000和100000，在put的过程中会进行扩容吗（腾讯云一面）

> 会啊，HashMap允许的size小于loadFactor×capacity，因此会进行扩容

concurrentHashMap的size如何计算（腾讯云一面）

红黑树的特点，平衡二叉树和红黑树的区别，查询和插入的时间复杂度（阿里3一面，腾讯云二面，百度一面）

> [红黑树深入剖析及Java实现](https://tech.meituan.com/2016/12/02/redblack-tree.html)
>
> 1. 任何一个节点都有颜色，黑色或者红色
> 2. 根节点是黑色的
> 3. 父子节点之间不能出现两个连续的红节点
> 4. 任何一个节点向下遍历到其子孙的叶子节点，所经过的黑节点个数必须相等
> 5. 空节点被认为是黑色的
>
> 红黑树在插入、删除等操作，不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁地调整。红黑树在最坏情况下，也能在O(logn)地时间复杂度下查找某个节点
>
> 整个红黑树的查找，插入和删除都是O(logN)的

红黑树在Java中的应用（腾讯云二面）

### 2.4 多线程

线程的创建的几种方法？Callable和Runnable的区别（华为Cloudbu一面，腾讯CDG一面）

> 一、线程创建的几种方法
>
> - 实现Runnable接口；
> - 实现Callable接口；
> - 继承Thread类
>
> 二、Callable和Runnable的区别
>
> - `Runnable`自 Java 1.0 以来一直存在，但`Callable`仅在 Java 1.5 中引入，目的就是为了来处理`Runnable`不支持的用例。
> - `Runnable` 接口 不会返回结果或抛出检查异常，但是 `Callable` 接口可以。

死锁的概念？如何避免死锁？(淘宝一面，腾讯CDG事务开发一面)

> 一、死锁的概念
>
> 多个线程同时被阻塞，它们中的一个或多个全部都在同时等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止
>
> 二、死锁的四个必要条件以及死锁避免
>
> 1、互斥
>
> - 每个资源要么已经分配给一个进程，要么就是可用的；
>
> - 无法破坏，因为我们用锁本来就是希望让它们互斥的
    >
    >   2、请求和保持
>
> - 已经得到了某个资源的进程可以再请求新的资源；
>
> - 破坏方法：一次性申请所有的资源
    >
    >   3、不可抢占
>
> - 已经分配给一个进程的资源不能强制性地抢占，它只能被占有它的进程显式地释放
>
> - 破坏方法：占有部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源
    >
    >   4、环路等待
>
> - 有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源
>
> - 破坏方法：按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放

synchronized的实现原理（腾讯TEG一面）

> - synchronized本质上是对对象监视器monitor的获取
>
> - 监视器锁（monitor）是依赖于底层的操作系统的 `Mutex Lock` 来实现的，Java 的线程是映射到操作系统的原生线程之上的。
>
> - 如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。

偏向锁和轻量级锁的实现（腾讯TEG一面）

> [Java6及以上版本对synchronized的优化](https://www.cnblogs.com/wuqinglong/p/9945618.html)
>
> - 偏向锁。偏向锁是针对于一个线程而言的, 线程获得锁之后就不会再有解锁等操作了, 这样可以省略很多开销. 假如有两个线程来竞争该锁话, 那么偏向锁就失效了, 进而升级成轻量级锁了。
>
> - 轻量级锁。线程会去循环地通过CAS去获取对象的锁。这个循环是有次数限制地，如果在循环结束之前CAS操作成功，则线程获取成功，否则则升级为重量级锁
>
> | 锁    | 优点                                | 缺点                        | 适用场景               |
> | ---- | --------------------------------- | ------------------------- | ------------------ |
> | 偏向锁  | 加锁和解锁不需要额外的消耗, 和执行非同步代码方法的性能相差无几. | 如果线程间存在锁竞争, 会带来额外的锁撤销的消耗. | 适用于只有一个线程访问的同步场景   |
> | 轻量级锁 | 竞争的线程不会阻塞, 提高了程序的响应速度             | 如果始终得不到锁竞争的线程, 使用自旋会消耗CPU | 追求响应时间, 同步快执行速度非常快 |
> | 重量级锁 | 线程竞争不适用自旋, 不会消耗CPU                | 线程堵塞, 响应时间缓慢              | 追求吞吐量, 同步快执行时间速度较长 |
>
> 首先要明确一点是引入这些锁是为了提高获取锁的效率, 要明白每种锁的使用场景, 比如偏向锁适合一个线程对一个锁的多次获取的情况; 轻量级锁适合锁执行体比较简单(即减少锁粒度或时间), 自旋一会儿就可以成功获取锁的情况。

synchronized和volatile的区别（百度一面）

> - `volatile` 关键字是线程同步的轻量级实现，所以 `volatile` 性能肯定比`synchronized`关键字要好。但是 `volatile` 关键字只能用于变量而 `synchronized` 关键字可以修饰方法以及代码块 。
> - `volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。
> - `volatile`关键字主要用于解决变量在多个线程之间的可见性，而 `synchronized` 关键字解决的是多个线程之间访问资源的同步性。

volatile保持可见性的原理（百度一面）

> 把变量声明为 **`volatile`** ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。
>
> 所以，**`volatile` 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。**
>
> ![volatile关键字的可见性](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/d49c5557-140b-4abf-adad-8aac3c9036cf.png)

synchronized和ReenterantLock的区别，ReenterantLock的使用场景（腾讯TEG一面）

> 1、两者都是可重入锁
>
> **“可重入锁”** 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。
>
> 2、synchronized依赖于JVM而ReentrantLock依赖于API
>
> - `synchronized` 是依赖于 JVM 实现的，并没有直接暴露给我们。
> - `ReentrantLock` 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。
>
> 3、ReentrantLock比synchronized增加了一些高级功能
>
> 相比`synchronized`，`ReentrantLock`增加了一些高级功能。主要来说主要有三点：
>
> - **等待可中断** : `ReentrantLock`提供了一种能够中断等待锁的线程的机制，通过 `lock.lockInterruptibly()` 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。
> - **可实现公平锁** : `ReentrantLock`可以指定是公平锁还是非公平锁。而`synchronized`只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。`ReentrantLock`默认情况是非公平的，可以通过 `ReentrantLock`类的`ReentrantLock(boolean fair)`构造方法来制定是否是公平的。
> - **可实现选择性通知（锁可以绑定多个条件）**: `synchronized`关键字与`wait()`和`notify()`/`notifyAll()`方法相结合可以实现等待/通知机制。`ReentrantLock`类当然也可以实现，但是需要借助于`Condition`接口与`newCondition()`方法。

什么是happen-before原则？（阿里3一面）

> 在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。
>
> happens-before原则：
>
> - 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前
> - 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系执行的结果一致，那么这种重排序并不非法

CAS（阿里3一面）

> CAS：Compare and Swap，翻译成比较并交换
>
> CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做

Java线程状态有哪些？（腾讯CDG一面）

> ![Java 线程的状态](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png)

多线程下，i++和++i是否是线程安全？使用volatile是否可以使它线程安全？（阿里3一面）

> [i++使线程安全的吗](https://segmentfault.com/a/1190000015401766)
>
> [long和double的线程安全问题](https://blog.csdn.net/qq_32924343/article/details/79083094)
>
> - 每个线程都有自己的工作内存，每个线程需要对共享变量操作时必须先把共享变量从主内存load到自己的工作内存，等完成对共享变量的操作时再save到主内存
> - 如果一个线程运算完后还没有刷到主内存，此时这个共享变量的值就被另一个主线程从主内存读取到了，这个时候读取的数据就是脏数据，它会覆盖其他线程计算完的值
> - 加上volatile让内存可见不能解决这个问题。因为volatile只能保证可见性，不能保证原子性。多个线程同时读到这个共享变量的值，就算保证其他线程修改的可见性，也不能保证线程之间读取到相同值然后相互覆盖对方的值的情况
> - 解决方法
    >   - 对i++操作的方法加同步锁，同步只能有一个线程执行i++操作
>   - 使用自持原子性操作的类，如Java.util.concurrent.atomic.AtomicInteger，它使用的是CAS算法

多线程加锁的方式？（腾讯CDG一面）

> - synchronized关键字
> - ReentrantLock实现类

ThreadLocal（腾讯CDG一面）

> `ThreadLocal`类主要解决的就是让每个线程绑定自己的值，使用`ThreadLocl`类来存储每个线程的私有数据。从而避免了线程安全问题。

Java如何创建线程池/线程池有哪几种，怎么使用（腾讯云二面、华为Cloudbu一面）

> 1、通过构造方法实现。ThreadPoolExecutor
>
> 2、通过Executor框架的工具类Executors来实现
>
> - FixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待
> - SingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照执行顺序（FIFO，LIFO，优先级）执行
> - CachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可以灵活回收空闲线程，若无可回收，则新建线程；

线程池在比较繁忙的时候也永远达不到最大的线程数，线程池参数的意义（腾讯云一面）

核心线程数，最大线程，阻塞队列和拒绝策略的概念（腾讯云二面）

> [Java线程池实现原理及其在美团业务中的实践](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)
>
> 1. 首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务
> 2. 如果workerCount<corePoolSize，则创建并启动一个线程来执行新提交的任务
> 3. 如果workerCount>=corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中
> 4. 如果workerCount>=corePoolSize&&workerCount<maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务
> 5. 如果workerCount>=maximumPoolSize，并且线程池内的阻塞队列已满，则根据拒绝策略来处理该任务，默认的处理方式是直接抛异常
>
> 拒绝策略：
>
> 1. AbortPolicy。抛出RejectedExecution来拒绝新任务的处理
> 2. CallerRunsPolicy
     >    - 调用执行自己的线程运行任务。但这个策略会降低对于新任务的提交速度，影响程序的整体性能。
>    - 另外这个策略喜欢增加队列容量
>    - 如果应用程序可以承受此延迟并且不能丢弃任何一个请求的话，可以选择这个策略
> 3. DiscardPolicy。不处理新任务，直接丢弃掉
> 4. DiscardOldestPolicy。丢弃最早的未处理的任务请求

java交替打印（百度一面）
