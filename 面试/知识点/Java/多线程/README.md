线程的创建的几种方法？Callable和Runnable的区别（华为Cloudbu一面，腾讯CDG一面）

> 一、线程创建的几种方法
>
> - 实现Runnable接口；
> - 实现Callable接口；
> - 继承Thread类
>
> 二、Callable和Runnable的区别
>
> - `Runnable`自 Java 1.0 以来一直存在，但`Callable`仅在 Java 1.5 中引入，目的就是为了来处理`Runnable`不支持的用例。
> - `Runnable` 接口 不会返回结果或抛出检查异常，但是 `Callable` 接口可以。

死锁的概念？如何避免死锁？(淘宝一面，腾讯CDG事务开发一面)

> 一、死锁的概念
>
> 多个线程同时被阻塞，它们中的一个或多个全部都在同时等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止
>
> 二、死锁的四个必要条件以及死锁避免
>
> 1、互斥
>
> - 每个资源要么已经分配给一个进程，要么就是可用的；
>
> - 无法破坏，因为我们用锁本来就是希望让它们互斥的
    >
    >   2、请求和保持
>
> - 已经得到了某个资源的进程可以再请求新的资源；
>
> - 破坏方法：一次性申请所有的资源
    >
    >   3、不可抢占
>
> - 已经分配给一个进程的资源不能强制性地抢占，它只能被占有它的进程显式地释放
>
> - 破坏方法：占有部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源
    >
    >   4、环路等待
>
> - 有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源
>
> - 破坏方法：按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放

synchronized的实现原理（腾讯TEG一面）

> - synchronized本质上是对对象监视器monitor的获取
>
> - 监视器锁（monitor）是依赖于底层的操作系统的 `Mutex Lock` 来实现的，Java 的线程是映射到操作系统的原生线程之上的。
>
> - 如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。

偏向锁和轻量级锁的实现（腾讯TEG一面）

> [Java6及以上版本对synchronized的优化](https://www.cnblogs.com/wuqinglong/p/9945618.html)
>
> - 偏向锁。偏向锁是针对于一个线程而言的, 线程获得锁之后就不会再有解锁等操作了, 这样可以省略很多开销. 假如有两个线程来竞争该锁话, 那么偏向锁就失效了, 进而升级成轻量级锁了。
>
> - 轻量级锁。线程会去循环地通过CAS去获取对象的锁。这个循环是有次数限制地，如果在循环结束之前CAS操作成功，则线程获取成功，否则则升级为重量级锁
>
> | 锁    | 优点                                | 缺点                        | 适用场景               |
> | ---- | --------------------------------- | ------------------------- | ------------------ |
> | 偏向锁  | 加锁和解锁不需要额外的消耗, 和执行非同步代码方法的性能相差无几. | 如果线程间存在锁竞争, 会带来额外的锁撤销的消耗. | 适用于只有一个线程访问的同步场景   |
> | 轻量级锁 | 竞争的线程不会阻塞, 提高了程序的响应速度             | 如果始终得不到锁竞争的线程, 使用自旋会消耗CPU | 追求响应时间, 同步快执行速度非常快 |
> | 重量级锁 | 线程竞争不适用自旋, 不会消耗CPU                | 线程堵塞, 响应时间缓慢              | 追求吞吐量, 同步快执行时间速度较长 |
>
> 首先要明确一点是引入这些锁是为了提高获取锁的效率, 要明白每种锁的使用场景, 比如偏向锁适合一个线程对一个锁的多次获取的情况; 轻量级锁适合锁执行体比较简单(即减少锁粒度或时间), 自旋一会儿就可以成功获取锁的情况。

synchronized和volatile的区别（百度一面）

> - `volatile` 关键字是线程同步的轻量级实现，所以 `volatile` 性能肯定比`synchronized`关键字要好。但是 `volatile` 关键字只能用于变量而 `synchronized` 关键字可以修饰方法以及代码块 。
> - `volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。
> - `volatile`关键字主要用于解决变量在多个线程之间的可见性，而 `synchronized` 关键字解决的是多个线程之间访问资源的同步性。

volatile保持可见性的原理（百度一面）

> 把变量声明为 **`volatile`** ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。
>
> 所以，**`volatile` 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。**
>
> ![volatile关键字的可见性](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/d49c5557-140b-4abf-adad-8aac3c9036cf.png)

synchronized和ReenterantLock的区别，ReenterantLock的使用场景（腾讯TEG一面）

> 1、两者都是可重入锁
>
> **“可重入锁”** 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。
>
> 2、synchronized依赖于JVM而ReentrantLock依赖于API
>
> - `synchronized` 是依赖于 JVM 实现的，并没有直接暴露给我们。
> - `ReentrantLock` 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。
>
> 3、ReentrantLock比synchronized增加了一些高级功能
>
> 相比`synchronized`，`ReentrantLock`增加了一些高级功能。主要来说主要有三点：
>
> - **等待可中断** : `ReentrantLock`提供了一种能够中断等待锁的线程的机制，通过 `lock.lockInterruptibly()` 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。
> - **可实现公平锁** : `ReentrantLock`可以指定是公平锁还是非公平锁。而`synchronized`只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。`ReentrantLock`默认情况是非公平的，可以通过 `ReentrantLock`类的`ReentrantLock(boolean fair)`构造方法来制定是否是公平的。
> - **可实现选择性通知（锁可以绑定多个条件）**: `synchronized`关键字与`wait()`和`notify()`/`notifyAll()`方法相结合可以实现等待/通知机制。`ReentrantLock`类当然也可以实现，但是需要借助于`Condition`接口与`newCondition()`方法。

什么是happen-before原则？（阿里3一面）

> 在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。
>
> happens-before原则：
>
> - 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前
> - 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系执行的结果一致，那么这种重排序并不非法

CAS（阿里3一面）

> CAS：Compare and Swap，翻译成比较并交换
>
> CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做

Java线程状态有哪些？（腾讯CDG一面）

> ![Java 线程的状态](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png)

多线程下，i++和++i是否是线程安全？使用volatile是否可以使它线程安全？（阿里3一面）

> [i++使线程安全的吗](https://segmentfault.com/a/1190000015401766)
>
> [long和double的线程安全问题](https://blog.csdn.net/qq_32924343/article/details/79083094)
>
> - 每个线程都有自己的工作内存，每个线程需要对共享变量操作时必须先把共享变量从主内存load到自己的工作内存，等完成对共享变量的操作时再save到主内存
> - 如果一个线程运算完后还没有刷到主内存，此时这个共享变量的值就被另一个主线程从主内存读取到了，这个时候读取的数据就是脏数据，它会覆盖其他线程计算完的值
> - 加上volatile让内存可见不能解决这个问题。因为volatile只能保证可见性，不能保证原子性。多个线程同时读到这个共享变量的值，就算保证其他线程修改的可见性，也不能保证线程之间读取到相同值然后相互覆盖对方的值的情况
> - 解决方法
    >   - 对i++操作的方法加同步锁，同步只能有一个线程执行i++操作
    >   - 使用自持原子性操作的类，如Java.util.concurrent.atomic.AtomicInteger，它使用的是CAS算法

多线程加锁的方式？（腾讯CDG一面）

> - synchronized关键字
> - ReentrantLock实现类

ThreadLocal（腾讯CDG一面）

> `ThreadLocal`类主要解决的就是让每个线程绑定自己的值，使用`ThreadLocl`类来存储每个线程的私有数据。从而避免了线程安全问题。

Java如何创建线程池/线程池有哪几种，怎么使用（腾讯云二面、华为Cloudbu一面）

> 1、通过构造方法实现。ThreadPoolExecutor
>
> 2、通过Executor框架的工具类Executors来实现
>
> - FixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待
> - SingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照执行顺序（FIFO，LIFO，优先级）执行
> - CachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可以灵活回收空闲线程，若无可回收，则新建线程；

线程池在比较繁忙的时候也永远达不到最大的线程数，线程池参数的意义（腾讯云一面）

核心线程数，最大线程，阻塞队列和拒绝策略的概念（腾讯云二面）

> [Java线程池实现原理及其在美团业务中的实践](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)
>
> 1. 首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务
> 2. 如果workerCount<corePoolSize，则创建并启动一个线程来执行新提交的任务
> 3. 如果workerCount>=corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中
> 4. 如果workerCount>=corePoolSize&&workerCount<maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务
> 5. 如果workerCount>=maximumPoolSize，并且线程池内的阻塞队列已满，则根据拒绝策略来处理该任务，默认的处理方式是直接抛异常
>
> 拒绝策略：
>
> 1. AbortPolicy。抛出RejectedExecution来拒绝新任务的处理
> 2. CallerRunsPolicy
     >    - 调用执行自己的线程运行任务。但这个策略会降低对于新任务的提交速度，影响程序的整体性能。
     >    - 另外这个策略喜欢增加队列容量
>    - 如果应用程序可以承受此延迟并且不能丢弃任何一个请求的话，可以选择这个策略
> 3. DiscardPolicy。不处理新任务，直接丢弃掉
> 4. DiscardOldestPolicy。丢弃最早的未处理的任务请求

java交替打印（百度一面）
