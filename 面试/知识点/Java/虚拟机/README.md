JVM的内存模型（百度一面）

> ![img](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.png)
>
> 一、程序计数器
>
> 程序计数器是线程私有的，它的生命周期与线程相同，主要有两个作用：
>
> 1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
> 2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
>
> 二、Java虚拟机栈
>
> - Java 虚拟机栈也是线程私有的，它的生命周期和线程相同
> - 描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。
> - Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。
>
> 三、本地方法栈
>
> - 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。
>
> 四、堆
>
> - Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。
> - 此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。
>
> 五、方法区
>
> - 方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

垃圾回收算法（腾讯CDG一面，腾讯TEG一面，深信服一面，百度一面）

> 一、判断对象是否可以被回收
>
> 1、引用计数算法。
>
> - 为对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1。
> - 引用计数为0的对象可被回收。但是当出现循环引用时，此时计数器永远不为0，导致无法对它们进行回收。
>
> 2、可达性分析算法
>
> - 以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收
> - Java 虚拟机使用该算法来判断对象是否可被回收
>
> 二、垃圾回收算法
>
> 1、标记-清除算法
>
> 该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。这种垃圾收集算法会带来两个明显的问题：
>
> - **效率问题**
>
> - **空间问题（标记清除后会产生大量不连续的碎片）**
>
> 2、标记-复制算法
>
> 为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。
>
> 3、标记-整理算法
>
> 根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。
>
> 4、分代收集算法
>
> **比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。**
>
> 三、垃圾收集器
>
> 1、[Serial 收集器](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_41-serial-%E6%94%B6%E9%9B%86%E5%99%A8)
>
> Serial（串行）收集器不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **"Stop The World"** ），直到它收集结束。
>
> 它**简单而高效（与其他收集器的单线程相比）**。
>
> **新生代采用标记-复制算法，老年代采用标记-整理算法。**
>
> ![Serial 收集器](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/46873026.png)
>
> 2、[ParNew 收集器](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_42-parnew-%E6%94%B6%E9%9B%86%E5%99%A8)
>
> **ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。**
>
> **新生代采用标记-复制算法，老年代采用标记-整理算法。**
>
> ![ParNew 收集器](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/22018368.png)
>
> 3、[Parallel Scavenge 收集器](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_43-parallel-scavenge-%E6%94%B6%E9%9B%86%E5%99%A8)
>
> **Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。**
>
> **新生代采用标记-复制算法，老年代采用标记-整理算法。**
>
> ![Parallel Scavenge 收集器](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/parllel-scavenge%E6%94%B6%E9%9B%86%E5%99%A8.png)
>
> 4、[Serial Old 收集器](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_44serial-old-%E6%94%B6%E9%9B%86%E5%99%A8)
>
> **Serial 收集器的老年代版本**，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。
>
> 5、[Parallel Old 收集器](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_45-parallel-old-%E6%94%B6%E9%9B%86%E5%99%A8)
>
> **Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。
>
> 6、[CMS 收集器](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_46-cms-%E6%94%B6%E9%9B%86%E5%99%A8)
>
> **CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。**
>
> **CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：
>
> - **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
> - **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
> - **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
> - **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。
>
> ![CMS 垃圾收集器](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png)
>
> 主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：
>
> - **对 CPU 资源敏感；**
> - **无法处理浮动垃圾；**
> - **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**
>
> 7、[G1 收集器](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_47-g1-%E6%94%B6%E9%9B%86%E5%99%A8)
>
> - **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
> - **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
> - **空间整合**：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。
> - **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。
>
> **G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)** 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

JVM的引用回收的计数器保存在哪里？（深信服一面）

> [对象引用计数保存在哪里？](https://blog.csdn.net/WangErice/article/details/105095579)

stop the world在哪些阶段发生（腾讯TEG一面）

> 垃圾回收时，必须暂停其他所有工作线程

在JVM和类加载的过程如何实现多态（腾讯云一面）

new一个对象的过程，从创建到垃圾回收，双亲委派机制（今日头条一面，腾讯CDG一面，腾讯云二面，华为公共开发一面）

> [java new一个对象的过程中发生了什么](https://www.cnblogs.com/JackPn/p/9386182.html)
>
> ![img](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E5%AE%8C%E5%96%84.png)
>
> 一、类加载过程
>
> 1、加载
>
> 由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例
>
> 2、验证
>
> 确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求
>
> 3、准备
>
> 为类中的所有静态变量分配内存空间，并为其设置一个初始值（由于还没有产生对象，实例变量不在此操作范围内）
>
> 4、解析
>
> 将常量池的符号引用替换为直接引用的过程。
>
> 其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。
>
> 5、初始化
>
> - 为静态变量赋值
>
> - 执行static代码块
>
> 因为子类存在对父类的依赖，所以**类的加载顺序是先加载父类后加载子类，初始化也一样。**不过，父类初始化时，子类静态变量的值也有有的，是默认值。
>
> 最终，方法区会存储当前类类信息，包括类的**静态变量**、**类初始化代码**（**定义静态变量时的赋值语句** 和 **静态初始化代码块**）、**实例变量定义**、**实例初始化代码**（**定义实例变量时的赋值语句实例代码块**和**构造方法**）和**实例方法**，还有**父类的类信息引用。**
>
> 二、创建对象
>
> 1、在堆区分配对象需要的内存
>
> - 分配的内存包括本类和父类的所有实例变量，但不包括任何静态变量
>
> 2、对所有实例变量赋默认值
>
> - 将方法区内对实例变量的定义拷贝一份到堆区，然后赋默认值
>
> 3、执行实例初始化代码
>
> - 初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法
>
> 4、如果有类似于Child c = new Child()形式的c引用的话，在栈区定义Child类型引用变量c，然后将堆区对象的地址赋值给它
>
> 三、双亲委派机制
>
> ![ClassLoader](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/classloader_WPS%E5%9B%BE%E7%89%87.png)
>
> 有一个类需要类加载器去加载，如果有父类，先让父类去加载，如此往上追朔，直到根类加载器，然后根类加载器尝试去加载，加载成功则结束，加载失败，又往下，一层层的尝试去加载，最终如果没有加载成功，则报错ClassNotFound。
