==和equals有什么区别（华为Cloudbu一面，腾讯CDG一面）

> - ==对于基本类型来说是值比较，对于引用类型来说是比较的引用；
> - String、Integer重写了equals方法，一般情况下equals比较的是值是否相等。

StringBuilder和StringBuffer（华为Cloudbu一面）

> 可变性：
> 
> - String不可变
> - StringBuffer和StringBuilder可变
> 
> 线程安全：
> 
> - String不可变，因此是线程安全的
> - StringBuilder不是线程安全的
> - StringBuffer是线程安全的，内部使用synchronized进行同步

接口和抽象类的区别（华为Cloudbu一面，淘宝一面，腾讯TEG一面）

> - 实现。抽象类的子类使用extends来继承（定义抽象类就是让其他类继承的），接口必须使用implements来实现接口；
> 
> - 构造函数。抽象类可以有构造函数；接口不能有
> 
> - main方法。抽象类可以有main方法，并且我们能运行它；接口不能有main方法。
> 
> - 实现数量。类可以实现很多个接口；但是只能继承一个抽象类
> 
> - 访问修饰符。接口中的方法默认使用public修饰；抽象类中的方法可以是任意访问修饰符。

继承和重载（华为Cloudbu一面）

> 继承：子类可以使用父类中的一些成员变量和方法，使用extends关键字实现
> 
> 重载：是指一个类中定义了多个重名方法，它们的参数列表是不相同的。

Java异常的类型（华为Cloudbu一面）

> ![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/PPjwP.png)

解释一下Java的序列化和反序列化？什么时候会用到？序列化的底层实现（腾讯CDG一面，深信服一面）

> - 序列化就是将一个对象转换为字节序列，方便存储和传输
>   - 序列化：ObjectOuputStream.writeObject()
>   - 反序列化：ObjectInputStream.readObject()
> - 不会对静态变量进行初始化，因为序列化只是保存对象的状态，静态变量属于类的状态
> - 序列化的类需要实现Serializable接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常
> - transient关键字可以使一些熟悉不会被序列化

Java的泛型（深信服一面）

> 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。

Java和Python的区别，各自有什么缺点？（深信服二面，今日头条测开二面）

> - Java必须显式声明变量名，而动态类型的Python不需要声明变量
> - Python虚拟机没有Java强，Java虚拟机是Java的核心，Python的核心是可以很方便地使用c语言函数或c++库
> - Java是一种静态类型语言，Python是一种动态类型语言
> - Java 的类型要声明，Python 的类型不需要
> - Python是全动态性的，可以在运行时自己修改自己的代码，Java只能通过变通方法实现

python是怎么执行的，需要编译链接吗？（今日头条测开二面）

> [python程序需要编译吗](https://cloud.tencent.com/developer/article/1725774)
> 
> 因为 Python 代码在运行前，会先编译（翻译）成中间代码，每个 .py 文件将被换转成 .pyc 文件，.pyc 就是一种字节码文件，它是与平台无关的中间代码，不管你放在 Windows 还是 Linux 平台都可以执行，运行时将由虚拟机逐行把字节码翻译成目标代码。
> 
> [Java到底是编译型语言还是解释型语言？](https://blog.fundebug.com/2019/01/25/is-java-a-compiled-or-an-interpreted-programming-language/)
> 
> java是解释型的语言，因为虽然java也需要编译，编译成.class文件，但是并不是机器可以识别的语言，而是字节码，最终还是需要 jvm的解释，才能在各个平台执行，这同时也是java跨平台的原因。所以可是说java即是编译型的，也是解释型，但是假如非要归类的话，从概念上的定义，恐怕java应该归到解释型的语言中

面向对象和面向过程的区别（阿里3一面）

> - 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了
> - 面向对象事把构成问题事物分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在解决问题的步骤中的行为

面向对象中的设计原则？使用了什么设计模式？（阿里3一面）

> - 单一责任原则。
>   - 修改一个类的原因只有一个
>   - 换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。
>   - 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱这个类完成其他职责的能力
> - 开放封闭原则
>   - 类应该对扩展开放，对修改关闭
>   - 扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码
>   - 符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码
> - 里氏替换原则
>   - 子类必须能够替换掉所有父类对象
>   - 继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。
>   - 如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。
> - 接口分离原则
>   - 不应该强迫客户依赖于它们不用的方法。
>   - 因此使用多个专门的接口比使用单一的总接口要好。
> - 依赖倒置原则
>   - 高层模块不应该依赖于低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。
>   - 高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。
>   - 依赖意味着
>     - 任何变量都不应该持有一个指向具体类的指针或者引用；
>     - 任何类都不应该从具体类派生；
>     - 任何方法都不应该覆写它的任何基类中的已经实现的方法。

设计模式有什么用？（阿里3一面）

> 为了代码可重用性、增加可维护性，让代码更容易被他人理解、保证代码可靠性。设计模式使代码真正工程化。

Java动态代理的场景（腾讯CDG一面）

> - 静态代理
>   - 概念
>     - 静态代理其实就是设计模式中的代理模式；
>     - 代理模式为其它对象提供一种代理以控制对这个对象的访问
>   - 缺点
>     - 大量使用这种静态代理，会使我们系统内的类的规模增大，并不易于维护；
>     - 并且由于Proxy和RealSubject的功能本质上是相同的，Proxy只是起到了中介的作用，这种代理在系统中的存在，导致系统结构比较臃肿和松散
> - 动态代理
>   - 概念
>     - 在运行状态中，需要代理的地方，根据Subject和RealSubject，动态地创建一个Proxy，用完之后，就会销毁，这样就可以避免Proxy角色的class在系统中冗余的问题了。
>     - Java动态代理基于经典代理模式，引入了一个InvocationHandler，InvocationHandler负责统一管理所有的方法调用。
>     - 基于Java内部的反射机制完成的
>   - 步骤
>     - 获取RealSubject上的所有接口列表
>     - 确定要生成的代理类的类名，默认为：com.sun.proxy.$ProxyXXXX
>     - 根据需要实现的接口信息，在代码中动态创建该Proxy类的字节码
>     - 将对应的字节码转换为对应的class对象
>     - 创建InvocationHandler实例handler，用来处理Proxy所有方法调用
>     - Proxy的class对象以创建的handler对象为参数，实例化一个proxy对象

Java的反射机制？（深信服一面）

> [深入理解Java反射](https://zhuanlan.zhihu.com/p/60805342)
> 
> 通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。
> 
> - **优点** ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利
> - **缺点** ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。