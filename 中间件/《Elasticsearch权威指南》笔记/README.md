## 一、入门

#### 集群和节点

- 节点(node)是一个运行着的ES实例；
- 集群(cluster)是一组具有相同cluster.name的结点

#### 面向文档

- ES是面向文档(document)的，这意味着它可以存储整个对象或文档；
- 它不仅仅是存储，还会索引每个文档的内容使之可以被搜索；
- 在ES中，可以对文档（而非成行成列的数据）进行索引、搜索、排序、过滤；
- ES使用JSON作为文档序列化格式；

#### 索引

- 一个索引(index)就像是关系数据库中的数据库，它是相关文档存储的地方；
- 传统数据库为特定列增加一个索引，例如B-Tree索引来加速检索。ES和Lucene使用一种倒排索引的数据结构来达到相同的目的
- ES集群可以包含多个索引(indices)（数据库），每个索引可以包括多个类型(types)（表），每一个类型包含多个文档(documents)（行），然后每个文档包含多个字段(Fields)（列）；
- 和传统关系型数据库的对比如下：

```json
Relational DB -> Databases -> Tables -> Rows -> Columns
Elasticsearch -> Indices -> Types -> Documents -> Fields
```

#### 分布式的特性

ES致力于隐藏分布式系统的复杂性。以下这些操作都是在底层自动完成的：

- 将文档分区到不同的容器或者分片(shards)中，它们可以存在于一个或多个节点中；
- 将分片均匀地分配到各个节点，对索引和搜索做负载均衡；
- 冗余每一个分片，防止硬件故障造成数据丢失；
- 将集群中任意一个节点上的请求路由到相应数据所在的节点；
- 无论是增加节点，还是移除节点，分片都可以做到无缝的扩展和迁移；

## 二、分布式集群

#### 空集群

- 集群中一个节点会被选举为主节点(master)，它将临时管理集群级别的一些变更，例如新建或删除索引、增加或移除节点等；
- 主节点不参与文档级别的变更或搜索；
- 任何节点都可能成为主节点；
- 每个节点都知道文档存在哪个节点，它们可以转发请求到相应的节点上；

#### 集群健康

| 颜色   | 意义                                         |
| ------ | -------------------------------------------- |
| green  | 所有主要分片和复制分片都可用                 |
| yellow | 所有主要分片都可用，但不是所有复制分片都可用 |
| red    | 不是所有主要分片都可用                       |

#### 添加索引

- 实际上，索引只是一个用来指向一个或多个分片(shards)的“逻辑命名空间”(logical namespace)；
- 一个分片是一个最小级别工作单元(work unit)，它只是保存索引中所有数据的一部分；
- 分片就是一个Lucene实例，并且它本身就是一个完整的搜索引擎；
- 分片是ES在集群中分发数据的关键，相当于数据的容器；
- 当集群扩容或缩小时，ES将会自动在节点间迁移分片，以使集群保持平衡；
- 分片可以是主分片(primary shard)或者是复制分片(replica shard)；
- 索引中的每个文档属于一个独立的主分片，所以分片的数量决定了索引最多存储多少数据；
- 复制分片只是主分片的一个副本，它可以防止硬件故障导致的数据丢失，同时可以提供读请求，比如搜索或者从别的分片取回文档；
- 当索引创建完成后，主分片的数量就固定了，但是复制分片的数量可以随时调整；
- 在一个结点上保存相同的数据副本是没有必要的，如果这个节点故障了，那所有的数据副本都会丢失

## 三、数据

#### 文档元数据

| 节点   | 说明               |
| ------ | ------------------ |
| _index | 文档存储的地方     |
| _type  | 文档代表的对象的类 |
| _id    | 文档的唯一标识     |

_index

- 索引名必须是全部小写，不能以下划线开头，不能包含逗号；

_type

- 使用相同类型的文档表示相同的“事物”，因为他们的数据结构是相同的；
- 每个类型都有自己的映射(mapping)或者结构定义，就像传统关系数据库中的列一样；
- 所有类型下的文档被存储在同一个索引下，但是类型的映射会告诉ES不同文档如何被索引

_id

- 在ES中唯一标识一个文档

#### 更新整个文档

- 文档在ES中是不可变的，我们不能修改它；

ES进行update操作的过程：

1. 从旧文档中检索JSON
2. 修改它
3. 删除旧文档
4. 索引新文档

#### 处理冲突

冲突的定义：

- 当使用index API更新文档时，我们读取原始文档，做修改，然后将整个文档一次性从新索引；
- 最近的索引请求会生效，ES只存储最后被索引的任何文档。如果其他人同时也修改这个文档，他们的修改将会丢失

在数据库中，有两种通用的方法确保在并发更新时修改不丢失：

- 悲观并发控制
  - 假设冲突的更改经常发生，为了解决冲突我们把访问区块化在；
  - 读一行数据前锁定这行，然后确保只有加锁的那个线程可以修改这行数据；
- 乐观并发控制
  - 被ES使用
  - 假设冲突不经常发生，也不区块化访问；
  - 如果在读写过程中数据发生了变化，更新操作将失败。这时候由程序决定在失败后如何解决冲突；
  - 实际情况中，可以重新尝试更新，刷新数据（重新读取）或者直接反馈给用户。

#### 乐观并发控制

- ES是分布式的。当文档被创建、更新或者删除，文档的新版本会被复制到集群的其它节点；
- ES即是同步也是异步的，意思是这些复制请求都是平行发送，并无需地到达目的地；
- 利用_version确保数据不会因为修改冲突而丢失。我们可以指定文档的version来做想要的更改。如果那个版本不是现在的，我们的请求就会失败

## 四、分布式文档存储

#### 路由文档到分片

文档所在的分片位置：

```json
shard = hash(routing) % number_of_primary_shards
```

- routing值是一个任意字符串，它默认是_id但也可以自定义；
- 这个routing字符串通过哈希函数生成一个数字，然后除以主分片的数量得到一个余数；
- 余数的范围永远是0到number_of_primary_shards-1，这个数字是特定文档所在的分片；
- 这也解释了为什么主分片的数量在创建索引时定义且不能更改：如果主分片的数量在未来改变了，所有先前的路由值就失效了，文档就永远找不到了

#### 新建、索引和删除文档

![新建、索引和删除单个文档](https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_0402.png)

1. 客户端给Node 1发送新建、索引或删除请求；

2. 节点使用文档的_id确定文档属于分片0；

3. Node 3在主分片上执行请求，如果成功，它转发请求到相应的位于Node 1和Node 2的复制节点上。当所有的复制节点报告成功，Node 3报告成功到请求的节点，请求的节点再报告给客户端

#### 检索文档

![取回单个文档](https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_0403.png)

1. 客户端给Node 1发送get请求；
2. 节点使用文档的_id确定文档属于分片0。分片0对应的复制分片在三个节点上都有。因此，它转发请求到Node 2；
3. Node 2返回endangered给Node 1，然后返回给客户端

对于读请求，为了平衡负载，请求节点会对每个请求选择不同的分片——它会循环所有分片副本

#### 局部更新文档

![局部更新文档](https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_0404.png)

1. 客户端给Node 1发送更新请求；
2. 它转发请求到主分片所在节点Node 3；
3. Node 3从主分片检索出文档，修改source字段的JSON，然后再主分片上重建索引。如果有其他进程修改了文档，他会以retry_on_conflict设置的次数重复步骤3，都未成功则放弃；
4. 如果Node 3成功更新文档，它同时转发文档的新版本到Node 1和Node 2的复制节点以重建索引。当所有复制节点报告成功，Node 3返回成功给请求节点，然后返回给客户端

## 五、搜索

搜索可以：

- 在类似于gender或者age这样的字段上使用结构化查询，join_date这样的字段使用排序，就像SQL的结构化查询一样；
- 全文检索，可以使用所有字段来匹配关键字，然后按照关联性排序返回结果；
- 或者结合以上两条

| 概念                        | 解释                           |
| --------------------------- | ------------------------------ |
| 映射(Mapping)               | 数据在每个字段的解释说明       |
| 分析(Analysis)              | 全文是如何处理的可以被搜索的   |
| 领域特定语言查询(Query DSL) | ES使用的灵活的、强大的查询语言 |

## 六、映射

映射(mapping)机制用于进行字段类型确认，将每个字段匹配为一种确定的数据类型(string, number, booleans, date等)；

分析(analysis)机制用于进行全文文本(Full Text)的分词，以建立供搜索用的反向索引；

#### 确切值(Exact value)和全文文本(Full Text)

- 确切值是确定的，正如它的名字一样。比如一个date或用户ID，也可以包含更多的字符串比如username或email地址；
- 全文文本是文本化的数据，比如一篇推文或邮件正文

#### 倒排索引

- ES使用一种叫做倒排索引(inverted index)的结构来做快速的全文搜索。倒排索引由在文档中出现的唯一的单词列表，以及对于每个单词在文档中的位置组成；
- 为了创建倒排索引，首先切分每个文档的content字段为单独的单词(可以成为terms或者tokens)，把所有的唯一词放入列表排序

#### 分析和分析器

分析(analysis)：

- 首先，表征化一个文本块为适用于倒排索引单独的词(term)；
- 然后标准化这些词为标准形式，提高它们的“可搜索性”或“查全率”

一个分析器(analyzer)只是一个包装用于将三个功能放到一个包里：

- 首先字符串经过字符过滤器(character filer)，它们的工作是表征化前处理处理字符串；
- 分词器(tokenizer)被表征化（断词）为独立的词。一个简单的分词器可以根据空格和逗号将单词分开；
- 最后，每个词都通过所有表征过滤(token filters)，它可以修改此（例如将Quick转为小写），去掉词（例如a, and, the），或者增加词（例如同义词）

## 七、分布式搜索

#### 查询阶段

![查询过程分布式搜索](https://www.elastic.co/guide/cn/elasticsearch/guide/2.x/images/elas_0901.png)

1. 客户端发送一个search请求给Node 3，Node 3创建了一个长度为from+size的空优先级队列；
2. Node 3转发这个搜索请求到索引中每个分片的原本和副本。每个分片在本地执行这个查询并将结果到一个大小为from+size的有序本地优先队列里；
3. 每个分片返回document的ID和它优先队列里的所有document的排序值给协调节点Node 3。Node 3把这些值合并到自己的优先队列里产生全局排序的结果

#### 取回阶段

![分布式搜索的取回阶段](https://www.elastic.co/guide/cn/elasticsearch/guide/2.x/images/elas_0902.png)

1. 协调节点辨别出哪个document需要取回，并且向相关分片发送GET请求；
2. 每个分片加载document并且根据需要丰富它们，然后再将document返回协调节点；
3. 一旦所有的document都被取回，协调节点会将结果返回给客户端

